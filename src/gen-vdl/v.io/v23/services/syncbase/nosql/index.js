// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
var vdl = require('vanadium').vdl;
var makeError = require('vanadium').verror.makeError;
var actions = require('vanadium').verror.actions;
var canonicalize = require('vanadium').vdl.canonicalize;





var time = require('./../../../vdlroot/time');
var access = require('./../../../security/access');
var permissions = require('./../../permissions');
var watch = require('./../../watch');

module.exports = {};



// Types:
var _type1 = new vdl.Type();
var _type10 = new vdl.Type();
var _type2 = new vdl.Type();
var _type3 = new vdl.Type();
var _type4 = new vdl.Type();
var _type5 = new vdl.Type();
var _type6 = new vdl.Type();
var _type7 = new vdl.Type();
var _type8 = new vdl.Type();
var _type9 = new vdl.Type();
var _typeBatchInfo = new vdl.Type();
var _typeBatchOptions = new vdl.Type();
var _typeBatchSource = new vdl.Type();
var _typeBlobFetchState = new vdl.Type();
var _typeBlobFetchStatus = new vdl.Type();
var _typeBlobRef = new vdl.Type();
var _typeConflictData = new vdl.Type();
var _typeConflictInfo = new vdl.Type();
var _typeCrPolicy = new vdl.Type();
var _typeCrRule = new vdl.Type();
var _typeKeyValue = new vdl.Type();
var _typeOperation = new vdl.Type();
var _typePrefixPermissions = new vdl.Type();
var _typeResolutionInfo = new vdl.Type();
var _typeResolverType = new vdl.Type();
var _typeRowInfo = new vdl.Type();
var _typeRowOp = new vdl.Type();
var _typeScanOp = new vdl.Type();
var _typeSchemaMetadata = new vdl.Type();
var _typeStoreChange = new vdl.Type();
var _typeSyncgroupMemberInfo = new vdl.Type();
var _typeSyncgroupSpec = new vdl.Type();
var _typeTableRow = new vdl.Type();
var _typeValue = new vdl.Type();
var _typeValueSelection = new vdl.Type();
var _typeValueState = new vdl.Type();
_type1.kind = vdl.kind.LIST;
_type1.name = "";
_type1.elem = vdl.types.STRING;
_type10.kind = vdl.kind.LIST;
_type10.name = "";
_type10.elem = _typePrefixPermissions;
_type2.kind = vdl.kind.LIST;
_type2.name = "";
_type2.elem = _typeTableRow;
_type3.kind = vdl.kind.MAP;
_type3.name = "";
_type3.elem = _typeSyncgroupMemberInfo;
_type3.key = vdl.types.STRING;
_type4.kind = vdl.kind.LIST;
_type4.name = "";
_type4.elem = vdl.types.BYTE;
_type5.kind = vdl.kind.LIST;
_type5.name = "";
_type5.elem = _typeCrRule;
_type6.kind = vdl.kind.OPTIONAL;
_type6.name = "";
_type6.elem = _typeValue;
_type7.kind = vdl.kind.LIST;
_type7.name = "";
_type7.elem = vdl.types.UINT64;
_type8.kind = vdl.kind.OPTIONAL;
_type8.name = "";
_type8.elem = _typeSchemaMetadata;
_type9.kind = vdl.kind.LIST;
_type9.name = "";
_type9.elem = vdl.types.ANY;
_typeBatchInfo.kind = vdl.kind.STRUCT;
_typeBatchInfo.name = "v.io/v23/services/syncbase/nosql.BatchInfo";
_typeBatchInfo.fields = [{name: "Id", type: vdl.types.UINT64}, {name: "Hint", type: vdl.types.STRING}, {name: "Source", type: _typeBatchSource}];
_typeBatchOptions.kind = vdl.kind.STRUCT;
_typeBatchOptions.name = "v.io/v23/services/syncbase/nosql.BatchOptions";
_typeBatchOptions.fields = [{name: "Hint", type: vdl.types.STRING}, {name: "ReadOnly", type: vdl.types.BOOL}];
_typeBatchSource.kind = vdl.kind.ENUM;
_typeBatchSource.name = "v.io/v23/services/syncbase/nosql.BatchSource";
_typeBatchSource.labels = ["Local", "Remote"];
_typeBlobFetchState.kind = vdl.kind.ENUM;
_typeBlobFetchState.name = "v.io/v23/services/syncbase/nosql.BlobFetchState";
_typeBlobFetchState.labels = ["Pending", "Locating", "Fetching", "Done"];
_typeBlobFetchStatus.kind = vdl.kind.STRUCT;
_typeBlobFetchStatus.name = "v.io/v23/services/syncbase/nosql.BlobFetchStatus";
_typeBlobFetchStatus.fields = [{name: "State", type: _typeBlobFetchState}, {name: "Received", type: vdl.types.INT64}, {name: "Total", type: vdl.types.INT64}];
_typeBlobRef.kind = vdl.kind.STRING;
_typeBlobRef.name = "v.io/v23/services/syncbase/nosql.BlobRef";
_typeConflictData.kind = vdl.kind.UNION;
_typeConflictData.name = "v.io/v23/services/syncbase/nosql.ConflictData";
_typeConflictData.fields = [{name: "Batch", type: _typeBatchInfo}, {name: "Row", type: _typeRowInfo}];
_typeConflictInfo.kind = vdl.kind.STRUCT;
_typeConflictInfo.name = "v.io/v23/services/syncbase/nosql.ConflictInfo";
_typeConflictInfo.fields = [{name: "Data", type: _typeConflictData}, {name: "Continued", type: vdl.types.BOOL}];
_typeCrPolicy.kind = vdl.kind.STRUCT;
_typeCrPolicy.name = "v.io/v23/services/syncbase/nosql.CrPolicy";
_typeCrPolicy.fields = [{name: "Rules", type: _type5}];
_typeCrRule.kind = vdl.kind.STRUCT;
_typeCrRule.name = "v.io/v23/services/syncbase/nosql.CrRule";
_typeCrRule.fields = [{name: "TableName", type: vdl.types.STRING}, {name: "KeyPrefix", type: vdl.types.STRING}, {name: "Type", type: vdl.types.STRING}, {name: "Resolver", type: _typeResolverType}];
_typeKeyValue.kind = vdl.kind.STRUCT;
_typeKeyValue.name = "v.io/v23/services/syncbase/nosql.KeyValue";
_typeKeyValue.fields = [{name: "Key", type: vdl.types.STRING}, {name: "Value", type: _type4}];
_typeOperation.kind = vdl.kind.UNION;
_typeOperation.name = "v.io/v23/services/syncbase/nosql.Operation";
_typeOperation.fields = [{name: "Read", type: _typeRowOp}, {name: "Write", type: _typeRowOp}, {name: "Scan", type: _typeScanOp}];
_typePrefixPermissions.kind = vdl.kind.STRUCT;
_typePrefixPermissions.name = "v.io/v23/services/syncbase/nosql.PrefixPermissions";
_typePrefixPermissions.fields = [{name: "Prefix", type: vdl.types.STRING}, {name: "Perms", type: new access.Permissions()._type}];
_typeResolutionInfo.kind = vdl.kind.STRUCT;
_typeResolutionInfo.name = "v.io/v23/services/syncbase/nosql.ResolutionInfo";
_typeResolutionInfo.fields = [{name: "Key", type: vdl.types.STRING}, {name: "Selection", type: _typeValueSelection}, {name: "Result", type: _type6}, {name: "Continued", type: vdl.types.BOOL}];
_typeResolverType.kind = vdl.kind.ENUM;
_typeResolverType.name = "v.io/v23/services/syncbase/nosql.ResolverType";
_typeResolverType.labels = ["LastWins", "AppResolves", "Defer"];
_typeRowInfo.kind = vdl.kind.STRUCT;
_typeRowInfo.name = "v.io/v23/services/syncbase/nosql.RowInfo";
_typeRowInfo.fields = [{name: "Op", type: _typeOperation}, {name: "BatchIds", type: _type7}];
_typeRowOp.kind = vdl.kind.STRUCT;
_typeRowOp.name = "v.io/v23/services/syncbase/nosql.RowOp";
_typeRowOp.fields = [{name: "Key", type: vdl.types.STRING}, {name: "LocalValue", type: _type6}, {name: "RemoteValue", type: _type6}, {name: "AncestorValue", type: _type6}];
_typeScanOp.kind = vdl.kind.STRUCT;
_typeScanOp.name = "v.io/v23/services/syncbase/nosql.ScanOp";
_typeScanOp.fields = [{name: "Start", type: vdl.types.STRING}, {name: "Limit", type: vdl.types.STRING}];
_typeSchemaMetadata.kind = vdl.kind.STRUCT;
_typeSchemaMetadata.name = "v.io/v23/services/syncbase/nosql.SchemaMetadata";
_typeSchemaMetadata.fields = [{name: "Version", type: vdl.types.INT32}, {name: "Policy", type: _typeCrPolicy}];
_typeStoreChange.kind = vdl.kind.STRUCT;
_typeStoreChange.name = "v.io/v23/services/syncbase/nosql.StoreChange";
_typeStoreChange.fields = [{name: "Value", type: _type4}, {name: "FromSync", type: vdl.types.BOOL}];
_typeSyncgroupMemberInfo.kind = vdl.kind.STRUCT;
_typeSyncgroupMemberInfo.name = "v.io/v23/services/syncbase/nosql.SyncgroupMemberInfo";
_typeSyncgroupMemberInfo.fields = [{name: "SyncPriority", type: vdl.types.BYTE}, {name: "IsServer", type: vdl.types.BOOL}];
_typeSyncgroupSpec.kind = vdl.kind.STRUCT;
_typeSyncgroupSpec.name = "v.io/v23/services/syncbase/nosql.SyncgroupSpec";
_typeSyncgroupSpec.fields = [{name: "Description", type: vdl.types.STRING}, {name: "Perms", type: new access.Permissions()._type}, {name: "Prefixes", type: _type2}, {name: "MountTables", type: _type1}, {name: "IsPrivate", type: vdl.types.BOOL}];
_typeTableRow.kind = vdl.kind.STRUCT;
_typeTableRow.name = "v.io/v23/services/syncbase/nosql.TableRow";
_typeTableRow.fields = [{name: "TableName", type: vdl.types.STRING}, {name: "Row", type: vdl.types.STRING}];
_typeValue.kind = vdl.kind.STRUCT;
_typeValue.name = "v.io/v23/services/syncbase/nosql.Value";
_typeValue.fields = [{name: "State", type: _typeValueState}, {name: "Bytes", type: _type4}, {name: "WriteTs", type: new time.Time()._type}];
_typeValueSelection.kind = vdl.kind.ENUM;
_typeValueSelection.name = "v.io/v23/services/syncbase/nosql.ValueSelection";
_typeValueSelection.labels = ["Local", "Remote", "Other"];
_typeValueState.kind = vdl.kind.ENUM;
_typeValueState.name = "v.io/v23/services/syncbase/nosql.ValueState";
_typeValueState.labels = ["Exists", "NoExists", "Deleted", "Unknown"];
_type1.freeze();
_type10.freeze();
_type2.freeze();
_type3.freeze();
_type4.freeze();
_type5.freeze();
_type6.freeze();
_type7.freeze();
_type8.freeze();
_type9.freeze();
_typeBatchInfo.freeze();
_typeBatchOptions.freeze();
_typeBatchSource.freeze();
_typeBlobFetchState.freeze();
_typeBlobFetchStatus.freeze();
_typeBlobRef.freeze();
_typeConflictData.freeze();
_typeConflictInfo.freeze();
_typeCrPolicy.freeze();
_typeCrRule.freeze();
_typeKeyValue.freeze();
_typeOperation.freeze();
_typePrefixPermissions.freeze();
_typeResolutionInfo.freeze();
_typeResolverType.freeze();
_typeRowInfo.freeze();
_typeRowOp.freeze();
_typeScanOp.freeze();
_typeSchemaMetadata.freeze();
_typeStoreChange.freeze();
_typeSyncgroupMemberInfo.freeze();
_typeSyncgroupSpec.freeze();
_typeTableRow.freeze();
_typeValue.freeze();
_typeValueSelection.freeze();
_typeValueState.freeze();
module.exports.BatchInfo = (vdl.registry.lookupOrCreateConstructor(_typeBatchInfo));
module.exports.BatchOptions = (vdl.registry.lookupOrCreateConstructor(_typeBatchOptions));
module.exports.BatchSource = {
  LOCAL: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeBatchSource))('Local', true), _typeBatchSource),
  REMOTE: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeBatchSource))('Remote', true), _typeBatchSource),
};
module.exports.BlobFetchState = {
  PENDING: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeBlobFetchState))('Pending', true), _typeBlobFetchState),
  LOCATING: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeBlobFetchState))('Locating', true), _typeBlobFetchState),
  FETCHING: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeBlobFetchState))('Fetching', true), _typeBlobFetchState),
  DONE: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeBlobFetchState))('Done', true), _typeBlobFetchState),
};
module.exports.BlobFetchStatus = (vdl.registry.lookupOrCreateConstructor(_typeBlobFetchStatus));
module.exports.BlobRef = (vdl.registry.lookupOrCreateConstructor(_typeBlobRef));
module.exports.ConflictData = (vdl.registry.lookupOrCreateConstructor(_typeConflictData));
module.exports.ConflictInfo = (vdl.registry.lookupOrCreateConstructor(_typeConflictInfo));
module.exports.CrPolicy = (vdl.registry.lookupOrCreateConstructor(_typeCrPolicy));
module.exports.CrRule = (vdl.registry.lookupOrCreateConstructor(_typeCrRule));
module.exports.KeyValue = (vdl.registry.lookupOrCreateConstructor(_typeKeyValue));
module.exports.Operation = (vdl.registry.lookupOrCreateConstructor(_typeOperation));
module.exports.PrefixPermissions = (vdl.registry.lookupOrCreateConstructor(_typePrefixPermissions));
module.exports.ResolutionInfo = (vdl.registry.lookupOrCreateConstructor(_typeResolutionInfo));
module.exports.ResolverType = {
  LAST_WINS: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeResolverType))('LastWins', true), _typeResolverType),
  APP_RESOLVES: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeResolverType))('AppResolves', true), _typeResolverType),
  DEFER: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeResolverType))('Defer', true), _typeResolverType),
};
module.exports.RowInfo = (vdl.registry.lookupOrCreateConstructor(_typeRowInfo));
module.exports.RowOp = (vdl.registry.lookupOrCreateConstructor(_typeRowOp));
module.exports.ScanOp = (vdl.registry.lookupOrCreateConstructor(_typeScanOp));
module.exports.SchemaMetadata = (vdl.registry.lookupOrCreateConstructor(_typeSchemaMetadata));
module.exports.StoreChange = (vdl.registry.lookupOrCreateConstructor(_typeStoreChange));
module.exports.SyncgroupMemberInfo = (vdl.registry.lookupOrCreateConstructor(_typeSyncgroupMemberInfo));
module.exports.SyncgroupSpec = (vdl.registry.lookupOrCreateConstructor(_typeSyncgroupSpec));
module.exports.TableRow = (vdl.registry.lookupOrCreateConstructor(_typeTableRow));
module.exports.Value = (vdl.registry.lookupOrCreateConstructor(_typeValue));
module.exports.ValueSelection = {
  LOCAL: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeValueSelection))('Local', true), _typeValueSelection),
  REMOTE: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeValueSelection))('Remote', true), _typeValueSelection),
  OTHER: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeValueSelection))('Other', true), _typeValueSelection),
};
module.exports.ValueState = {
  EXISTS: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeValueState))('Exists', true), _typeValueState),
  NO_EXISTS: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeValueState))('NoExists', true), _typeValueState),
  DELETED: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeValueState))('Deleted', true), _typeValueState),
  UNKNOWN: canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeValueState))('Unknown', true), _typeValueState),
};




// Consts:

  module.exports.NullBlobRef = canonicalize.reduce(new (vdl.registry.lookupOrCreateConstructor(_typeBlobRef))("", true), _typeBlobRef);



// Errors:

module.exports.BoundToBatchError = makeError('v.io/v23/services/syncbase/nosql.BoundToBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} bound to batch',
}, [
]);


module.exports.NotBoundToBatchError = makeError('v.io/v23/services/syncbase/nosql.NotBoundToBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} not bound to batch',
}, [
]);


module.exports.ReadOnlyBatchError = makeError('v.io/v23/services/syncbase/nosql.ReadOnlyBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} batch is read-only',
}, [
]);


module.exports.ConcurrentBatchError = makeError('v.io/v23/services/syncbase/nosql.ConcurrentBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} concurrent batch',
}, [
]);


module.exports.SchemaVersionMismatchError = makeError('v.io/v23/services/syncbase/nosql.SchemaVersionMismatch', actions.NO_RETRY, {
  'en': '{1:}{2:} actual schema version does not match the provided one',
}, [
]);


module.exports.BlobNotCommittedError = makeError('v.io/v23/services/syncbase/nosql.BlobNotCommitted', actions.NO_RETRY, {
  'en': '{1:}{2:} blob is not yet committed',
}, [
]);


module.exports.SyncgroupJoinFailedError = makeError('v.io/v23/services/syncbase/nosql.SyncgroupJoinFailed', actions.NO_RETRY, {
  'en': '{1:}{2:} syncgroup join failed',
}, [
]);




// Services:

  
    
function DatabaseWatcher(){}
module.exports.DatabaseWatcher = DatabaseWatcher;

    
      
DatabaseWatcher.prototype.getResumeMarker = function(ctx, serverCall) {
  throw new Error('Method GetResumeMarker not implemented');
};
    
      
DatabaseWatcher.prototype.watchGlob = function(ctx, serverCall, req) {
  throw new Error('Method WatchGlob not implemented');
};
     

    
DatabaseWatcher.prototype._serviceDescription = {
  name: 'DatabaseWatcher',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// DatabaseWatcher allows a client to watch for updates to the database. For\n// each watch request, the client will receive a reliable stream of watch events\n// without re-ordering. See watch.GlobWatcher for a detailed explanation of the\n// behavior.\n// TODO(rogulenko): Currently the only supported watch patterns are\n// \"<tableName>/<rowPrefix>*\". Consider changing that.\n//\n// Watching is done by starting a streaming RPC. The RPC takes a ResumeMarker\n// argument that points to a particular place in the database event log. If an\n// empty ResumeMarker is provided, the WatchStream will begin with a Change\n// batch containing the initial state. Otherwise, the WatchStream will contain\n// only changes since the provided ResumeMarker.\n//\n// The result stream consists of a never-ending sequence of Change messages\n// (until the call fails or is canceled). Each Change contains the Name field\n// in the form \"<tableName>/<rowKey>\" and the Value field of the StoreChange\n// type. If the client has no access to a row specified in a change, that change\n// is excluded from the result stream.\n//\n// Note: A single Watch Change batch may contain changes from more than one\n// batch as originally committed on a remote Syncbase or obtained from conflict\n// resolution. However, changes from a single original batch will always appear\n// in the same Change batch.",
  embeds: [{
      name: 'GlobWatcher',
      pkgPath: 'v.io/v23/services/watch',
      doc: "// GlobWatcher allows a client to receive updates for changes to objects\n// that match a pattern.  See the package comments for details."
    },
    ],
  methods: [
    
      
    {
    name: 'GetResumeMarker',
    doc: "// GetResumeMarker returns the ResumeMarker that points to the current end\n// of the event log. GetResumeMarker() can be called on a batch.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: new watch.ResumeMarker()._type
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'WatchGlob',
    doc: "// WatchGlob returns a stream of changes that match a pattern.",
    inArgs: [{
      name: 'req',
      doc: "",
      type: new watch.GlobRequest()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: new watch.Change()._type
    },
    tags: [canonicalize.reduce(new access.Tag("Resolve", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function SyncgroupManager(){}
module.exports.SyncgroupManager = SyncgroupManager;

    
      
SyncgroupManager.prototype.getSyncgroupNames = function(ctx, serverCall) {
  throw new Error('Method GetSyncgroupNames not implemented');
};
    
      
SyncgroupManager.prototype.createSyncgroup = function(ctx, serverCall, sgName, spec, myInfo) {
  throw new Error('Method CreateSyncgroup not implemented');
};
    
      
SyncgroupManager.prototype.joinSyncgroup = function(ctx, serverCall, sgName, myInfo) {
  throw new Error('Method JoinSyncgroup not implemented');
};
    
      
SyncgroupManager.prototype.leaveSyncgroup = function(ctx, serverCall, sgName) {
  throw new Error('Method LeaveSyncgroup not implemented');
};
    
      
SyncgroupManager.prototype.destroySyncgroup = function(ctx, serverCall, sgName) {
  throw new Error('Method DestroySyncgroup not implemented');
};
    
      
SyncgroupManager.prototype.ejectFromSyncgroup = function(ctx, serverCall, sgName, member) {
  throw new Error('Method EjectFromSyncgroup not implemented');
};
    
      
SyncgroupManager.prototype.getSyncgroupSpec = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncgroupSpec not implemented');
};
    
      
SyncgroupManager.prototype.setSyncgroupSpec = function(ctx, serverCall, sgName, spec, version) {
  throw new Error('Method SetSyncgroupSpec not implemented');
};
    
      
SyncgroupManager.prototype.getSyncgroupMembers = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncgroupMembers not implemented');
};
     

    
SyncgroupManager.prototype._serviceDescription = {
  name: 'SyncgroupManager',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// SyncgroupManager is the interface for syncgroup operations.\n// TODO(hpucha): Add blessings to create/join and add a refresh method.",
  embeds: [],
  methods: [
    
      
    {
    name: 'GetSyncgroupNames',
    doc: "// GetSyncgroupNames returns the global names of all syncgroups attached to\n// this database.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _type1
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'CreateSyncgroup',
    doc: "// CreateSyncgroup creates a new syncgroup with the given spec.\n//\n// Requires: Client must have at least Read access on the Database; prefix ACL\n// must exist at each syncgroup prefix; Client must have at least Read access\n// on each of these prefix ACLs.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncgroupMemberInfo
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'JoinSyncgroup',
    doc: "// JoinSyncgroup joins the syncgroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncgroupMemberInfo
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'LeaveSyncgroup',
    doc: "// LeaveSyncgroup leaves the syncgroup. Previously synced data will continue\n// to be available.\n//\n// Requires: Client must have at least Read access on the Database.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DestroySyncgroup',
    doc: "// DestroySyncgroup destroys the syncgroup. Previously synced data will\n// continue to be available to all members.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'EjectFromSyncgroup',
    doc: "// EjectFromSyncgroup ejects a member from the syncgroup. The ejected member\n// will not be able to sync further, but will retain any data it has already\n// synced.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'member',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncgroupSpec',
    doc: "// GetSyncgroupSpec gets the syncgroup spec. version allows for atomic\n// read-modify-write of the spec - see comment for SetSyncgroupSpec.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetSyncgroupSpec',
    doc: "// SetSyncgroupSpec sets the syncgroup spec. version may be either empty or\n// the value from a previous Get. If not empty, Set will only succeed if the\n// current version matches the specified one.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncgroupMembers',
    doc: "// GetSyncgroupMembers gets the info objects for members of the syncgroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'members',
      doc: "",
      type: _type3
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function BlobManager(){}
module.exports.BlobManager = BlobManager;

    
      
BlobManager.prototype.createBlob = function(ctx, serverCall) {
  throw new Error('Method CreateBlob not implemented');
};
    
      
BlobManager.prototype.putBlob = function(ctx, serverCall, br) {
  throw new Error('Method PutBlob not implemented');
};
    
      
BlobManager.prototype.commitBlob = function(ctx, serverCall, br) {
  throw new Error('Method CommitBlob not implemented');
};
    
      
BlobManager.prototype.getBlobSize = function(ctx, serverCall, br) {
  throw new Error('Method GetBlobSize not implemented');
};
    
      
BlobManager.prototype.deleteBlob = function(ctx, serverCall, br) {
  throw new Error('Method DeleteBlob not implemented');
};
    
      
BlobManager.prototype.getBlob = function(ctx, serverCall, br, offset) {
  throw new Error('Method GetBlob not implemented');
};
    
      
BlobManager.prototype.fetchBlob = function(ctx, serverCall, br, priority) {
  throw new Error('Method FetchBlob not implemented');
};
    
      
BlobManager.prototype.pinBlob = function(ctx, serverCall, br) {
  throw new Error('Method PinBlob not implemented');
};
    
      
BlobManager.prototype.unpinBlob = function(ctx, serverCall, br) {
  throw new Error('Method UnpinBlob not implemented');
};
    
      
BlobManager.prototype.keepBlob = function(ctx, serverCall, br, rank) {
  throw new Error('Method KeepBlob not implemented');
};
     

    
BlobManager.prototype._serviceDescription = {
  name: 'BlobManager',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// BlobManager is the interface for blob operations.\n//\n// Description of API for resumable blob creation (append-only):\n// - Up until commit, a BlobRef may be used with PutBlob, GetBlobSize,\n//   DeleteBlob, and CommitBlob. Blob creation may be resumed by obtaining the\n//   current blob size via GetBlobSize and appending to the blob via PutBlob.\n// - After commit, a blob is immutable, at which point PutBlob and CommitBlob\n//   may no longer be used.\n// - All other methods (GetBlob, FetchBlob, PinBlob, etc.) may only be used\n//   after commit.",
  embeds: [],
  methods: [
    
      
    {
    name: 'CreateBlob',
    doc: "// CreateBlob returns a BlobRef for a newly created blob.",
    inArgs: [],
    outArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'PutBlob',
    doc: "// PutBlob appends the byte stream to the blob.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: {
      name: '',
      doc: '',
      type: _type4
    },
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'CommitBlob',
    doc: "// CommitBlob marks the blob as immutable.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetBlobSize',
    doc: "// GetBlobSize returns the count of bytes written as part of the blob\n// (committed or uncommitted).",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.INT64
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeleteBlob',
    doc: "// DeleteBlob locally deletes the blob (committed or uncommitted).",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetBlob',
    doc: "// GetBlob returns the byte stream from a committed blob starting at offset.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    {
      name: 'offset',
      doc: "",
      type: vdl.types.INT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _type4
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'FetchBlob',
    doc: "// FetchBlob initiates fetching a blob if not locally found. priority\n// controls the network priority of the blob. Higher priority blobs are\n// fetched before the lower priority ones. However, an ongoing blob\n// transfer is not interrupted. Status updates are streamed back to the\n// client as fetch is in progress.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    {
      name: 'priority',
      doc: "",
      type: vdl.types.UINT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _typeBlobFetchStatus
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'PinBlob',
    doc: "// PinBlob locally pins the blob so that it is not evicted.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'UnpinBlob',
    doc: "// UnpinBlob locally unpins the blob so that it can be evicted if needed.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'KeepBlob',
    doc: "// KeepBlob locally caches the blob with the specified rank. Lower\n// ranked blobs are more eagerly evicted.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    {
      name: 'rank',
      doc: "",
      type: vdl.types.UINT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function SchemaManager(){}
module.exports.SchemaManager = SchemaManager;

    
      
SchemaManager.prototype.getSchemaMetadata = function(ctx, serverCall) {
  throw new Error('Method GetSchemaMetadata not implemented');
};
    
      
SchemaManager.prototype.setSchemaMetadata = function(ctx, serverCall, metadata) {
  throw new Error('Method SetSchemaMetadata not implemented');
};
     

    
SchemaManager.prototype._serviceDescription = {
  name: 'SchemaManager',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// SchemaManager implements the API for managing schema metadata attached\n// to a Database.",
  embeds: [],
  methods: [
    
      
    {
    name: 'GetSchemaMetadata',
    doc: "// GetSchemaMetadata retrieves schema metadata for this database.\n//\n// Requires: Client must have at least Read access on the Database.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _typeSchemaMetadata
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetSchemaMetadata',
    doc: "// SetSchemaMetadata stores schema metadata for this database.\n//\n// Requires: Client must have at least Write access on the Database.",
    inArgs: [{
      name: 'metadata',
      doc: "",
      type: _typeSchemaMetadata
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function ConflictManager(){}
module.exports.ConflictManager = ConflictManager;

    
      
ConflictManager.prototype.startConflictResolver = function(ctx, serverCall) {
  throw new Error('Method StartConflictResolver not implemented');
};
     

    
ConflictManager.prototype._serviceDescription = {
  name: 'ConflictManager',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// ConflictManager interface provides all the methods necessary to handle\n// conflict resolution for a given database.",
  embeds: [],
  methods: [
    
      
    {
    name: 'StartConflictResolver',
    doc: "// StartConflictResolver registers a resolver for the database that is\n// associated with this ConflictManager and creates a stream to receive\n// conflicts and send resolutions.\n// Batches of ConflictInfos will be sent over with the Continued field\n// within the ConflictInfo representing the batch boundary. Client must\n// respond with a batch of ResolutionInfos in the same fashion.\n// A key is under conflict if two different values were written to it\n// concurrently (in logical time), i.e. neither value is an ancestor of the\n// other in the history graph.\n// A key under conflict can be a part of a batch committed on local or\n// remote or both syncbases. ConflictInfos for all keys in these two batches\n// are grouped together. These keys may themselves be under conflict; the\n// presented batch is a transitive closure of all batches containing keys\n// under conflict.\n// For example, for local batch {key1, key2} and remote batch {key1, key3},\n// the batch sent for conflict resolution will be {key1, key2, key3}.\n// If there was another concurrent batch {key2, key4}, then the batch sent\n// for conflict resolution will be {key1, key2, key3, key4}.",
    inArgs: [],
    outArgs: [],
    inStream: {
      name: '',
      doc: '',
      type: _typeResolutionInfo
    },
    outStream: {
      name: '',
      doc: '',
      type: _typeConflictInfo
    },
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Database(){}
module.exports.Database = Database;

    
      
Database.prototype.create = function(ctx, serverCall, metadata, perms) {
  throw new Error('Method Create not implemented');
};
    
      
Database.prototype.destroy = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Destroy not implemented');
};
    
      
Database.prototype.exists = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Exists not implemented');
};
    
      
Database.prototype.listTables = function(ctx, serverCall) {
  throw new Error('Method ListTables not implemented');
};
    
      
Database.prototype.exec = function(ctx, serverCall, schemaVersion, query, params) {
  throw new Error('Method Exec not implemented');
};
    
      
Database.prototype.beginBatch = function(ctx, serverCall, schemaVersion, bo) {
  throw new Error('Method BeginBatch not implemented');
};
    
      
Database.prototype.commit = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Commit not implemented');
};
    
      
Database.prototype.abort = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Abort not implemented');
};
    
      
Database.prototype.pauseSync = function(ctx, serverCall) {
  throw new Error('Method PauseSync not implemented');
};
    
      
Database.prototype.resumeSync = function(ctx, serverCall) {
  throw new Error('Method ResumeSync not implemented');
};
    
      
Database.prototype.setPermissions = function(ctx, serverCall, perms, version) {
  throw new Error('Method SetPermissions not implemented');
};
    
      
Database.prototype.getPermissions = function(ctx, serverCall) {
  throw new Error('Method GetPermissions not implemented');
};
    
      
Database.prototype.getResumeMarker = function(ctx, serverCall) {
  throw new Error('Method GetResumeMarker not implemented');
};
    
      
Database.prototype.watchGlob = function(ctx, serverCall, req) {
  throw new Error('Method WatchGlob not implemented');
};
    
      
Database.prototype.getSyncgroupNames = function(ctx, serverCall) {
  throw new Error('Method GetSyncgroupNames not implemented');
};
    
      
Database.prototype.createSyncgroup = function(ctx, serverCall, sgName, spec, myInfo) {
  throw new Error('Method CreateSyncgroup not implemented');
};
    
      
Database.prototype.joinSyncgroup = function(ctx, serverCall, sgName, myInfo) {
  throw new Error('Method JoinSyncgroup not implemented');
};
    
      
Database.prototype.leaveSyncgroup = function(ctx, serverCall, sgName) {
  throw new Error('Method LeaveSyncgroup not implemented');
};
    
      
Database.prototype.destroySyncgroup = function(ctx, serverCall, sgName) {
  throw new Error('Method DestroySyncgroup not implemented');
};
    
      
Database.prototype.ejectFromSyncgroup = function(ctx, serverCall, sgName, member) {
  throw new Error('Method EjectFromSyncgroup not implemented');
};
    
      
Database.prototype.getSyncgroupSpec = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncgroupSpec not implemented');
};
    
      
Database.prototype.setSyncgroupSpec = function(ctx, serverCall, sgName, spec, version) {
  throw new Error('Method SetSyncgroupSpec not implemented');
};
    
      
Database.prototype.getSyncgroupMembers = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncgroupMembers not implemented');
};
    
      
Database.prototype.createBlob = function(ctx, serverCall) {
  throw new Error('Method CreateBlob not implemented');
};
    
      
Database.prototype.putBlob = function(ctx, serverCall, br) {
  throw new Error('Method PutBlob not implemented');
};
    
      
Database.prototype.commitBlob = function(ctx, serverCall, br) {
  throw new Error('Method CommitBlob not implemented');
};
    
      
Database.prototype.getBlobSize = function(ctx, serverCall, br) {
  throw new Error('Method GetBlobSize not implemented');
};
    
      
Database.prototype.deleteBlob = function(ctx, serverCall, br) {
  throw new Error('Method DeleteBlob not implemented');
};
    
      
Database.prototype.getBlob = function(ctx, serverCall, br, offset) {
  throw new Error('Method GetBlob not implemented');
};
    
      
Database.prototype.fetchBlob = function(ctx, serverCall, br, priority) {
  throw new Error('Method FetchBlob not implemented');
};
    
      
Database.prototype.pinBlob = function(ctx, serverCall, br) {
  throw new Error('Method PinBlob not implemented');
};
    
      
Database.prototype.unpinBlob = function(ctx, serverCall, br) {
  throw new Error('Method UnpinBlob not implemented');
};
    
      
Database.prototype.keepBlob = function(ctx, serverCall, br, rank) {
  throw new Error('Method KeepBlob not implemented');
};
    
      
Database.prototype.getSchemaMetadata = function(ctx, serverCall) {
  throw new Error('Method GetSchemaMetadata not implemented');
};
    
      
Database.prototype.setSchemaMetadata = function(ctx, serverCall, metadata) {
  throw new Error('Method SetSchemaMetadata not implemented');
};
    
      
Database.prototype.startConflictResolver = function(ctx, serverCall) {
  throw new Error('Method StartConflictResolver not implemented');
};
     

    
Database.prototype._serviceDescription = {
  name: 'Database',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// Database represents a collection of Tables. Batches, queries, sync, watch,\n// etc. all operate at the Database level.\n// Database.Glob operates over Table names.\n// Param schemaVersion is the version number that the client expects the\n// database to be at. To disable schema version checking, pass -1.",
  embeds: [{
      name: 'Object',
      pkgPath: 'v.io/v23/services/permissions',
      doc: "// Object provides access control for Vanadium objects.\n//\n// Vanadium services implementing dynamic access control would typically embed\n// this interface and tag additional methods defined by the service with one of\n// Admin, Read, Write, Resolve etc. For example, the VDL definition of the\n// object would be:\n//\n//   package mypackage\n//\n//   import \"v.io/v23/security/access\"\n//   import \"v.io/v23/services/permissions\"\n//\n//   type MyObject interface {\n//     permissions.Object\n//     MyRead() (string, error) {access.Read}\n//     MyWrite(string) error    {access.Write}\n//   }\n//\n// If the set of pre-defined tags is insufficient, services may define their\n// own tag type and annotate all methods with this new type.\n//\n// Instead of embedding this Object interface, define SetPermissions and\n// GetPermissions in their own interface. Authorization policies will typically\n// respect annotations of a single type. For example, the VDL definition of an\n// object would be:\n//\n//  package mypackage\n//\n//  import \"v.io/v23/security/access\"\n//\n//  type MyTag string\n//\n//  const (\n//    Blue = MyTag(\"Blue\")\n//    Red  = MyTag(\"Red\")\n//  )\n//\n//  type MyObject interface {\n//    MyMethod() (string, error) {Blue}\n//\n//    // Allow clients to change access via the access.Object interface:\n//    SetPermissions(perms access.Permissions, version string) error         {Red}\n//    GetPermissions() (perms access.Permissions, version string, err error) {Blue}\n//  }"
    },
    {
      name: 'DatabaseWatcher',
      pkgPath: 'v.io/v23/services/syncbase/nosql',
      doc: "// DatabaseWatcher allows a client to watch for updates to the database. For\n// each watch request, the client will receive a reliable stream of watch events\n// without re-ordering. See watch.GlobWatcher for a detailed explanation of the\n// behavior.\n// TODO(rogulenko): Currently the only supported watch patterns are\n// \"<tableName>/<rowPrefix>*\". Consider changing that.\n//\n// Watching is done by starting a streaming RPC. The RPC takes a ResumeMarker\n// argument that points to a particular place in the database event log. If an\n// empty ResumeMarker is provided, the WatchStream will begin with a Change\n// batch containing the initial state. Otherwise, the WatchStream will contain\n// only changes since the provided ResumeMarker.\n//\n// The result stream consists of a never-ending sequence of Change messages\n// (until the call fails or is canceled). Each Change contains the Name field\n// in the form \"<tableName>/<rowKey>\" and the Value field of the StoreChange\n// type. If the client has no access to a row specified in a change, that change\n// is excluded from the result stream.\n//\n// Note: A single Watch Change batch may contain changes from more than one\n// batch as originally committed on a remote Syncbase or obtained from conflict\n// resolution. However, changes from a single original batch will always appear\n// in the same Change batch."
    },
    {
      name: 'SyncgroupManager',
      pkgPath: 'v.io/v23/services/syncbase/nosql',
      doc: "// SyncgroupManager is the interface for syncgroup operations.\n// TODO(hpucha): Add blessings to create/join and add a refresh method."
    },
    {
      name: 'BlobManager',
      pkgPath: 'v.io/v23/services/syncbase/nosql',
      doc: "// BlobManager is the interface for blob operations.\n//\n// Description of API for resumable blob creation (append-only):\n// - Up until commit, a BlobRef may be used with PutBlob, GetBlobSize,\n//   DeleteBlob, and CommitBlob. Blob creation may be resumed by obtaining the\n//   current blob size via GetBlobSize and appending to the blob via PutBlob.\n// - After commit, a blob is immutable, at which point PutBlob and CommitBlob\n//   may no longer be used.\n// - All other methods (GetBlob, FetchBlob, PinBlob, etc.) may only be used\n//   after commit."
    },
    {
      name: 'SchemaManager',
      pkgPath: 'v.io/v23/services/syncbase/nosql',
      doc: "// SchemaManager implements the API for managing schema metadata attached\n// to a Database."
    },
    {
      name: 'ConflictManager',
      pkgPath: 'v.io/v23/services/syncbase/nosql',
      doc: "// ConflictManager interface provides all the methods necessary to handle\n// conflict resolution for a given database."
    },
    ],
  methods: [
    
      
    {
    name: 'Create',
    doc: "// Create creates this Database.\n// If perms is nil, we inherit (copy) the App perms.\n// Create requires the caller to have Write permission at the App.",
    inArgs: [{
      name: 'metadata',
      doc: "",
      type: _type8
    },
    {
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Destroy',
    doc: "// Destroy destroys this Database, permanently removing all of its data.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Exists',
    doc: "// Exists returns true only if this Database exists. Insufficient permissions\n// cause Exists to return false instead of an error.\n// TODO(ivanpi): Exists may fail with an error if higher levels of hierarchy\n// do not exist.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.BOOL
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Resolve", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'ListTables',
    doc: "// ListTables returns a list of all Table names.\n// This method exists on Database but not on Service or App because for the\n// latter we can simply use glob, while for the former glob fails on\n// BatchDatabase since we encode the batch id in the BatchDatabase object\n// name. More specifically, the glob client library appears to have two odd\n// behaviors:\n// 1) It checks Resolve access on every component along the path (by doing a\n//    Dispatcher.Lookup), whereas this doesn't happen for other RPCs.\n// 2) It does a Glob(<prefix>/*) for every prefix path, and only proceeds to\n//    the next path component if that component appeared in its parent's Glob\n//    results. This is inefficient in general, and broken for us since\n//    Glob(\"app/*\") does not return batch database names like \"a/d##bId\".\n// TODO(sadovsky): Maybe switch to streaming RPC.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _type1
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Exec',
    doc: "// Exec executes a syncQL query with positional parameters and returns all\n// results as specified by the query's select/delete statement.\n// Concurrency semantics are documented in model.go.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'query',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'params',
      doc: "",
      type: _type9
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _type9
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'BeginBatch',
    doc: "// BeginBatch creates a new batch. It returns a \"batch suffix\" string to\n// append to the object name of this Database, yielding an object name for the\n// Database bound to the created batch. (For example, if this Database is\n// named \"/path/to/db\" and BeginBatch returns \"##abc\", the client should\n// construct batch Database object name \"/path/to/db##abc\".) If this Database\n// is already bound to a batch, BeginBatch() will fail with ErrBoundToBatch.\n// Concurrency semantics are documented in model.go.\n// TODO(sadovsky): Maybe make BatchOptions optional. Also, rename it to 'opts'\n// everywhere now that v.io/i/912 is resolved.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'bo',
      doc: "",
      type: _typeBatchOptions
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Commit',
    doc: "// Commit persists the pending changes to the database.\n// If this Database is not bound to a batch, Commit() will fail with\n// ErrNotBoundToBatch.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Abort',
    doc: "// Abort notifies the server that any pending changes can be discarded.\n// It is not strictly required, but it may allow the server to release locks\n// or other resources sooner than if it was not called.\n// If this Database is not bound to a batch, Abort() will fail with\n// ErrNotBoundToBatch.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'PauseSync',
    doc: "// PauseSync pauses sync for this database. Incoming sync, as well as\n// outgoing sync of subsequent writes, will be disabled until ResumeSync\n// is called. PauseSync is idempotent.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'ResumeSync',
    doc: "// ResumeSync resumes sync for this database. ResumeSync is idempotent.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetPermissions',
    doc: "// SetPermissions replaces the current Permissions for an object.  version\n// allows for optional, optimistic concurrency control.  If non-empty,\n// version's value must come from GetPermissions.  If any client has\n// successfully called SetPermissions in the meantime, the version will be\n// stale and SetPermissions will fail.  If empty, SetPermissions performs an\n// unconditional update.\n//\n// Permissions objects are expected to be small.  It is up to the\n// implementation to define the exact limit, though it should probably be\n// around 100KB.  Large lists of principals can be represented concisely using\n// blessings.\n//\n// There is some ambiguity when calling SetPermissions on a mount point.\n// Does it affect the mount itself or does it affect the service endpoint\n// that the mount points to?  The chosen behavior is that it affects the\n// service endpoint.  To modify the mount point's Permissions, use\n// ResolveToMountTable to get an endpoint and call SetPermissions on that.\n// This means that clients must know when a name refers to a mount point to\n// change its Permissions.",
    inArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetPermissions',
    doc: "// GetPermissions returns the complete, current Permissions for an object. The\n// returned version can be passed to a subsequent call to SetPermissions for\n// optimistic concurrency control. A successful call to SetPermissions will\n// invalidate version, and the client must call GetPermissions again to get\n// the current version.",
    inArgs: [],
    outArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetResumeMarker',
    doc: "// GetResumeMarker returns the ResumeMarker that points to the current end\n// of the event log. GetResumeMarker() can be called on a batch.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: new watch.ResumeMarker()._type
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'WatchGlob',
    doc: "// WatchGlob returns a stream of changes that match a pattern.",
    inArgs: [{
      name: 'req',
      doc: "",
      type: new watch.GlobRequest()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: new watch.Change()._type
    },
    tags: [canonicalize.reduce(new access.Tag("Resolve", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncgroupNames',
    doc: "// GetSyncgroupNames returns the global names of all syncgroups attached to\n// this database.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _type1
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'CreateSyncgroup',
    doc: "// CreateSyncgroup creates a new syncgroup with the given spec.\n//\n// Requires: Client must have at least Read access on the Database; prefix ACL\n// must exist at each syncgroup prefix; Client must have at least Read access\n// on each of these prefix ACLs.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncgroupMemberInfo
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'JoinSyncgroup',
    doc: "// JoinSyncgroup joins the syncgroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncgroupMemberInfo
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'LeaveSyncgroup',
    doc: "// LeaveSyncgroup leaves the syncgroup. Previously synced data will continue\n// to be available.\n//\n// Requires: Client must have at least Read access on the Database.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DestroySyncgroup',
    doc: "// DestroySyncgroup destroys the syncgroup. Previously synced data will\n// continue to be available to all members.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'EjectFromSyncgroup',
    doc: "// EjectFromSyncgroup ejects a member from the syncgroup. The ejected member\n// will not be able to sync further, but will retain any data it has already\n// synced.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'member',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncgroupSpec',
    doc: "// GetSyncgroupSpec gets the syncgroup spec. version allows for atomic\n// read-modify-write of the spec - see comment for SetSyncgroupSpec.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetSyncgroupSpec',
    doc: "// SetSyncgroupSpec sets the syncgroup spec. version may be either empty or\n// the value from a previous Get. If not empty, Set will only succeed if the\n// current version matches the specified one.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncgroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncgroupMembers',
    doc: "// GetSyncgroupMembers gets the info objects for members of the syncgroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// syncgroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'members',
      doc: "",
      type: _type3
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'CreateBlob',
    doc: "// CreateBlob returns a BlobRef for a newly created blob.",
    inArgs: [],
    outArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'PutBlob',
    doc: "// PutBlob appends the byte stream to the blob.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: {
      name: '',
      doc: '',
      type: _type4
    },
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'CommitBlob',
    doc: "// CommitBlob marks the blob as immutable.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetBlobSize',
    doc: "// GetBlobSize returns the count of bytes written as part of the blob\n// (committed or uncommitted).",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.INT64
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeleteBlob',
    doc: "// DeleteBlob locally deletes the blob (committed or uncommitted).",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetBlob',
    doc: "// GetBlob returns the byte stream from a committed blob starting at offset.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    {
      name: 'offset',
      doc: "",
      type: vdl.types.INT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _type4
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'FetchBlob',
    doc: "// FetchBlob initiates fetching a blob if not locally found. priority\n// controls the network priority of the blob. Higher priority blobs are\n// fetched before the lower priority ones. However, an ongoing blob\n// transfer is not interrupted. Status updates are streamed back to the\n// client as fetch is in progress.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    {
      name: 'priority',
      doc: "",
      type: vdl.types.UINT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _typeBlobFetchStatus
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'PinBlob',
    doc: "// PinBlob locally pins the blob so that it is not evicted.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'UnpinBlob',
    doc: "// UnpinBlob locally unpins the blob so that it can be evicted if needed.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'KeepBlob',
    doc: "// KeepBlob locally caches the blob with the specified rank. Lower\n// ranked blobs are more eagerly evicted.",
    inArgs: [{
      name: 'br',
      doc: "",
      type: _typeBlobRef
    },
    {
      name: 'rank',
      doc: "",
      type: vdl.types.UINT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSchemaMetadata',
    doc: "// GetSchemaMetadata retrieves schema metadata for this database.\n//\n// Requires: Client must have at least Read access on the Database.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _typeSchemaMetadata
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetSchemaMetadata',
    doc: "// SetSchemaMetadata stores schema metadata for this database.\n//\n// Requires: Client must have at least Write access on the Database.",
    inArgs: [{
      name: 'metadata',
      doc: "",
      type: _typeSchemaMetadata
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'StartConflictResolver',
    doc: "// StartConflictResolver registers a resolver for the database that is\n// associated with this ConflictManager and creates a stream to receive\n// conflicts and send resolutions.\n// Batches of ConflictInfos will be sent over with the Continued field\n// within the ConflictInfo representing the batch boundary. Client must\n// respond with a batch of ResolutionInfos in the same fashion.\n// A key is under conflict if two different values were written to it\n// concurrently (in logical time), i.e. neither value is an ancestor of the\n// other in the history graph.\n// A key under conflict can be a part of a batch committed on local or\n// remote or both syncbases. ConflictInfos for all keys in these two batches\n// are grouped together. These keys may themselves be under conflict; the\n// presented batch is a transitive closure of all batches containing keys\n// under conflict.\n// For example, for local batch {key1, key2} and remote batch {key1, key3},\n// the batch sent for conflict resolution will be {key1, key2, key3}.\n// If there was another concurrent batch {key2, key4}, then the batch sent\n// for conflict resolution will be {key1, key2, key3, key4}.",
    inArgs: [],
    outArgs: [],
    inStream: {
      name: '',
      doc: '',
      type: _typeResolutionInfo
    },
    outStream: {
      name: '',
      doc: '',
      type: _typeConflictInfo
    },
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Table(){}
module.exports.Table = Table;

    
      
Table.prototype.create = function(ctx, serverCall, schemaVersion, perms) {
  throw new Error('Method Create not implemented');
};
    
      
Table.prototype.destroy = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Destroy not implemented');
};
    
      
Table.prototype.exists = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Exists not implemented');
};
    
      
Table.prototype.getPermissions = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method GetPermissions not implemented');
};
    
      
Table.prototype.setPermissions = function(ctx, serverCall, schemaVersion, perms) {
  throw new Error('Method SetPermissions not implemented');
};
    
      
Table.prototype.deleteRange = function(ctx, serverCall, schemaVersion, start, limit) {
  throw new Error('Method DeleteRange not implemented');
};
    
      
Table.prototype.scan = function(ctx, serverCall, schemaVersion, start, limit) {
  throw new Error('Method Scan not implemented');
};
    
      
Table.prototype.getPrefixPermissions = function(ctx, serverCall, schemaVersion, key) {
  throw new Error('Method GetPrefixPermissions not implemented');
};
    
      
Table.prototype.setPrefixPermissions = function(ctx, serverCall, schemaVersion, prefix, perms) {
  throw new Error('Method SetPrefixPermissions not implemented');
};
    
      
Table.prototype.deletePrefixPermissions = function(ctx, serverCall, schemaVersion, prefix) {
  throw new Error('Method DeletePrefixPermissions not implemented');
};
     

    
Table.prototype._serviceDescription = {
  name: 'Table',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// Table represents a collection of Rows.\n// Table.Glob operates over the primary keys of Rows in the Table.\n// SchemaVersion is the version number that the client expects the database\n// to be at. To disable schema version checking, pass -1.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Create',
    doc: "// Create creates this Table.\n// If perms is nil, we inherit (copy) the Database perms.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Destroy',
    doc: "// Destroy destroys this Table.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Exists',
    doc: "// Exists returns true only if this Table exists. Insufficient permissions\n// cause Exists to return false instead of an error.\n// TODO(ivanpi): Exists may fail with an error if higher levels of hierarchy\n// do not exist.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.BOOL
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Resolve", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetPermissions',
    doc: "// GetPermissions returns the current Permissions for the Table.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetPermissions',
    doc: "// SetPermissions replaces the current Permissions for the Table.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeleteRange',
    doc: "// DeleteRange deletes all rows in the given half-open range [start, limit).\n// If limit is \"\", all rows with keys >= start are included.\n// TODO(sadovsky): Maybe add option to delete prefix perms fully covered by\n// the row range.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'start',
      doc: "",
      type: _type4
    },
    {
      name: 'limit',
      doc: "",
      type: _type4
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Scan',
    doc: "// Scan returns all rows in the given half-open range [start, limit). If limit\n// is \"\", all rows with keys >= start are included. Concurrency semantics are\n// documented in model.go.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'start',
      doc: "",
      type: _type4
    },
    {
      name: 'limit',
      doc: "",
      type: _type4
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _typeKeyValue
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetPrefixPermissions',
    doc: "// GetPrefixPermissions returns an array of (prefix, perms) pairs. The array is\n// sorted from longest prefix to shortest, so element zero is the one that\n// applies to the row with the given key. The last element is always the\n// prefix \"\" which represents the table's permissions -- the array will always\n// have at least one element.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'key',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: _type10
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetPrefixPermissions',
    doc: "// SetPrefixPermissions sets the permissions for all current and future rows with\n// the given prefix. If the prefix overlaps with an existing prefix, the\n// longest prefix that matches a row applies. For example:\n//     SetPrefixPermissions(ctx, Prefix(\"a/b\"), perms1)\n//     SetPrefixPermissions(ctx, Prefix(\"a/b/c\"), perms2)\n// The permissions for row \"a/b/1\" are perms1, and the permissions for row\n// \"a/b/c/1\" are perms2.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'prefix',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeletePrefixPermissions',
    doc: "// DeletePrefixPermissions deletes the permissions for the specified prefix. Any\n// rows covered by this prefix will use the next longest prefix's permissions\n// (see the array returned by GetPrefixPermissions).",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'prefix',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Row(){}
module.exports.Row = Row;

    
      
Row.prototype.exists = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Exists not implemented');
};
    
      
Row.prototype.get = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Get not implemented');
};
    
      
Row.prototype.put = function(ctx, serverCall, schemaVersion, value) {
  throw new Error('Method Put not implemented');
};
    
      
Row.prototype.delete = function(ctx, serverCall, schemaVersion) {
  throw new Error('Method Delete not implemented');
};
     

    
Row.prototype._serviceDescription = {
  name: 'Row',
  pkgPath: 'v.io/v23/services/syncbase/nosql',
  doc: "// Row represents a single row in a Table.\n// All access checks are performed against the most specific matching prefix\n// permissions in the Table.\n// SchemaVersion is the version number that the client expects the database\n// to be at. To disable schema version checking, pass -1.\n// NOTE(sadovsky): Currently we send []byte values over the wire for Get, Put,\n// and Scan. If there's a way to avoid encoding/decoding on the server side, we\n// can use vdl.Value everywhere without sacrificing performance.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Exists',
    doc: "// Exists returns true only if this Row exists. Insufficient permissions\n// cause Exists to return false instead of an error.\n// Note, Exists on Row requires read permissions, unlike higher levels of\n// hierarchy which require resolve, because Row existence usually carries\n// more information.\n// TODO(ivanpi): Exists may fail with an error if higher levels of hierarchy\n// do not exist.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.BOOL
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Get',
    doc: "// Get returns the value for this Row.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: _type4
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Put',
    doc: "// Put writes the given value for this Row.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    {
      name: 'value',
      doc: "",
      type: _type4
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete deletes this Row.",
    inArgs: [{
      name: 'schemaVersion',
      doc: "",
      type: vdl.types.INT32
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
     
  ]
};

   

   
 


