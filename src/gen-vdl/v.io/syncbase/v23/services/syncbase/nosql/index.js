// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
var vdl = require('vanadium').vdl;
var makeError = require('vanadium').verror.makeError;
var actions = require('vanadium').verror.actions;
var canonicalize = require('vanadium').vdl.canonicalize;





var access = require('./../../../../../v23/security/access');
var permissions = require('./../../../../../v23/services/permissions');

module.exports = {};



// Types:
var _type1 = new vdl.Type();
var _type2 = new vdl.Type();
var _type3 = new vdl.Type();
var _type4 = new vdl.Type();
var _type5 = new vdl.Type();
var _typeBatchOptions = new vdl.Type();
var _typeKeyValue = new vdl.Type();
var _typePrefixPermissions = new vdl.Type();
var _typeSyncGroupMemberInfo = new vdl.Type();
var _typeSyncGroupSpec = new vdl.Type();
_type1.kind = vdl.kind.LIST;
_type1.name = "";
_type1.elem = vdl.types.STRING;
_type2.kind = vdl.kind.MAP;
_type2.name = "";
_type2.elem = _typeSyncGroupMemberInfo;
_type2.key = vdl.types.STRING;
_type3.kind = vdl.kind.LIST;
_type3.name = "";
_type3.elem = vdl.types.ANY;
_type4.kind = vdl.kind.LIST;
_type4.name = "";
_type4.elem = vdl.types.BYTE;
_type5.kind = vdl.kind.LIST;
_type5.name = "";
_type5.elem = _typePrefixPermissions;
_typeBatchOptions.kind = vdl.kind.STRUCT;
_typeBatchOptions.name = "v.io/syncbase/v23/services/syncbase/nosql.BatchOptions";
_typeBatchOptions.fields = [{name: "Hint", type: vdl.types.STRING}, {name: "ReadOnly", type: vdl.types.BOOL}];
_typeKeyValue.kind = vdl.kind.STRUCT;
_typeKeyValue.name = "v.io/syncbase/v23/services/syncbase/nosql.KeyValue";
_typeKeyValue.fields = [{name: "Key", type: vdl.types.STRING}, {name: "Value", type: _type4}];
_typePrefixPermissions.kind = vdl.kind.STRUCT;
_typePrefixPermissions.name = "v.io/syncbase/v23/services/syncbase/nosql.PrefixPermissions";
_typePrefixPermissions.fields = [{name: "Prefix", type: vdl.types.STRING}, {name: "Perms", type: new access.Permissions()._type}];
_typeSyncGroupMemberInfo.kind = vdl.kind.STRUCT;
_typeSyncGroupMemberInfo.name = "v.io/syncbase/v23/services/syncbase/nosql.SyncGroupMemberInfo";
_typeSyncGroupMemberInfo.fields = [{name: "SyncPriority", type: vdl.types.BYTE}];
_typeSyncGroupSpec.kind = vdl.kind.STRUCT;
_typeSyncGroupSpec.name = "v.io/syncbase/v23/services/syncbase/nosql.SyncGroupSpec";
_typeSyncGroupSpec.fields = [{name: "Description", type: vdl.types.STRING}, {name: "Perms", type: new access.Permissions()._type}, {name: "Prefixes", type: _type1}, {name: "MountTables", type: _type1}, {name: "IsPrivate", type: vdl.types.BOOL}];
_type1.freeze();
_type2.freeze();
_type3.freeze();
_type4.freeze();
_type5.freeze();
_typeBatchOptions.freeze();
_typeKeyValue.freeze();
_typePrefixPermissions.freeze();
_typeSyncGroupMemberInfo.freeze();
_typeSyncGroupSpec.freeze();
module.exports.BatchOptions = (vdl.registry.lookupOrCreateConstructor(_typeBatchOptions));
module.exports.KeyValue = (vdl.registry.lookupOrCreateConstructor(_typeKeyValue));
module.exports.PrefixPermissions = (vdl.registry.lookupOrCreateConstructor(_typePrefixPermissions));
module.exports.SyncGroupMemberInfo = (vdl.registry.lookupOrCreateConstructor(_typeSyncGroupMemberInfo));
module.exports.SyncGroupSpec = (vdl.registry.lookupOrCreateConstructor(_typeSyncGroupSpec));




// Consts:



// Errors:

module.exports.BoundToBatchError = makeError('v.io/syncbase/v23/services/syncbase/nosql.BoundToBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} bound to batch',
}, [
]);


module.exports.NotBoundToBatchError = makeError('v.io/syncbase/v23/services/syncbase/nosql.NotBoundToBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} not bound to batch',
}, [
]);


module.exports.ReadOnlyBatchError = makeError('v.io/syncbase/v23/services/syncbase/nosql.ReadOnlyBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} batch is read-only',
}, [
]);




// Services:

  
    
function SyncGroupManager(){}
module.exports.SyncGroupManager = SyncGroupManager;

    
      
SyncGroupManager.prototype.getSyncGroupNames = function(ctx, serverCall) {
  throw new Error('Method GetSyncGroupNames not implemented');
};
    
      
SyncGroupManager.prototype.createSyncGroup = function(ctx, serverCall, sgName, spec, myInfo) {
  throw new Error('Method CreateSyncGroup not implemented');
};
    
      
SyncGroupManager.prototype.joinSyncGroup = function(ctx, serverCall, sgName, myInfo) {
  throw new Error('Method JoinSyncGroup not implemented');
};
    
      
SyncGroupManager.prototype.leaveSyncGroup = function(ctx, serverCall, sgName) {
  throw new Error('Method LeaveSyncGroup not implemented');
};
    
      
SyncGroupManager.prototype.destroySyncGroup = function(ctx, serverCall, sgName) {
  throw new Error('Method DestroySyncGroup not implemented');
};
    
      
SyncGroupManager.prototype.ejectFromSyncGroup = function(ctx, serverCall, sgName, member) {
  throw new Error('Method EjectFromSyncGroup not implemented');
};
    
      
SyncGroupManager.prototype.getSyncGroupSpec = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncGroupSpec not implemented');
};
    
      
SyncGroupManager.prototype.setSyncGroupSpec = function(ctx, serverCall, sgName, spec, version) {
  throw new Error('Method SetSyncGroupSpec not implemented');
};
    
      
SyncGroupManager.prototype.getSyncGroupMembers = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncGroupMembers not implemented');
};
     

    
SyncGroupManager.prototype._serviceDescription = {
  name: 'SyncGroupManager',
  pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
  doc: "// SyncGroupManager is the interface for SyncGroup operations.\n// TODO(hpucha): Add blessings to create/join and add a refresh method.",
  embeds: [],
  methods: [
    
      
    {
    name: 'GetSyncGroupNames',
    doc: "// GetSyncGroupNames returns the global names of all SyncGroups attached to\n// this database.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _type1
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'CreateSyncGroup',
    doc: "// CreateSyncGroup creates a new SyncGroup with the given spec.\n//\n// Requires: Client must have at least Read access on the Database; prefix ACL\n// must exist at each SyncGroup prefix; Client must have at least Read access\n// on each of these prefix ACLs.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncGroupMemberInfo
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'JoinSyncGroup',
    doc: "// JoinSyncGroup joins the SyncGroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncGroupMemberInfo
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'LeaveSyncGroup',
    doc: "// LeaveSyncGroup leaves the SyncGroup. Previously synced data will continue\n// to be available.\n//\n// Requires: Client must have at least Read access on the Database.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DestroySyncGroup',
    doc: "// DestroySyncGroup destroys the SyncGroup. Previously synced data will\n// continue to be available to all members.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'EjectFromSyncGroup',
    doc: "// EjectFromSyncGroup ejects a member from the SyncGroup. The ejected member\n// will not be able to sync further, but will retain any data it has already\n// synced.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'member',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncGroupSpec',
    doc: "// GetSyncGroupSpec gets the SyncGroup spec. version allows for atomic\n// read-modify-write of the spec - see comment for SetSyncGroupSpec.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetSyncGroupSpec',
    doc: "// SetSyncGroupSpec sets the SyncGroup spec. version may be either empty or\n// the value from a previous Get. If not empty, Set will only succeed if the\n// current version matches the specified one.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncGroupMembers',
    doc: "// GetSyncGroupMembers gets the info objects for members of the SyncGroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'members',
      doc: "",
      type: _type2
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Database(){}
module.exports.Database = Database;

    
      
Database.prototype.create = function(ctx, serverCall, perms) {
  throw new Error('Method Create not implemented');
};
    
      
Database.prototype.delete = function(ctx, serverCall) {
  throw new Error('Method Delete not implemented');
};
    
      
Database.prototype.beginBatch = function(ctx, serverCall, bo) {
  throw new Error('Method BeginBatch not implemented');
};
    
      
Database.prototype.commit = function(ctx, serverCall) {
  throw new Error('Method Commit not implemented');
};
    
      
Database.prototype.exec = function(ctx, serverCall, query) {
  throw new Error('Method Exec not implemented');
};
    
      
Database.prototype.abort = function(ctx, serverCall) {
  throw new Error('Method Abort not implemented');
};
    
      
Database.prototype.setPermissions = function(ctx, serverCall, perms, version) {
  throw new Error('Method SetPermissions not implemented');
};
    
      
Database.prototype.getPermissions = function(ctx, serverCall) {
  throw new Error('Method GetPermissions not implemented');
};
    
      
Database.prototype.getSyncGroupNames = function(ctx, serverCall) {
  throw new Error('Method GetSyncGroupNames not implemented');
};
    
      
Database.prototype.createSyncGroup = function(ctx, serverCall, sgName, spec, myInfo) {
  throw new Error('Method CreateSyncGroup not implemented');
};
    
      
Database.prototype.joinSyncGroup = function(ctx, serverCall, sgName, myInfo) {
  throw new Error('Method JoinSyncGroup not implemented');
};
    
      
Database.prototype.leaveSyncGroup = function(ctx, serverCall, sgName) {
  throw new Error('Method LeaveSyncGroup not implemented');
};
    
      
Database.prototype.destroySyncGroup = function(ctx, serverCall, sgName) {
  throw new Error('Method DestroySyncGroup not implemented');
};
    
      
Database.prototype.ejectFromSyncGroup = function(ctx, serverCall, sgName, member) {
  throw new Error('Method EjectFromSyncGroup not implemented');
};
    
      
Database.prototype.getSyncGroupSpec = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncGroupSpec not implemented');
};
    
      
Database.prototype.setSyncGroupSpec = function(ctx, serverCall, sgName, spec, version) {
  throw new Error('Method SetSyncGroupSpec not implemented');
};
    
      
Database.prototype.getSyncGroupMembers = function(ctx, serverCall, sgName) {
  throw new Error('Method GetSyncGroupMembers not implemented');
};
     

    
Database.prototype._serviceDescription = {
  name: 'Database',
  pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
  doc: "// Database represents a collection of Tables. Batches, queries, sync, watch,\n// etc. all operate at the Database level.\n// Database.Glob operates over Table names.\n//\n// TODO(sadovsky): Add Watch method.",
  embeds: [{
      name: 'Object',
      pkgPath: 'v.io/v23/services/permissions',
      doc: "// Object provides access control for Vanadium objects.\n//\n// Vanadium services implementing dynamic access control would typically embed\n// this interface and tag additional methods defined by the service with one of\n// Admin, Read, Write, Resolve etc. For example, the VDL definition of the\n// object would be:\n//\n//   package mypackage\n//\n//   import \"v.io/v23/security/access\"\n//   import \"v.io/v23/services/permissions\"\n//\n//   type MyObject interface {\n//     permissions.Object\n//     MyRead() (string, error) {access.Read}\n//     MyWrite(string) error    {access.Write}\n//   }\n//\n// If the set of pre-defined tags is insufficient, services may define their\n// own tag type and annotate all methods with this new type.\n//\n// Instead of embedding this Object interface, define SetPermissions and\n// GetPermissions in their own interface. Authorization policies will typically\n// respect annotations of a single type. For example, the VDL definition of an\n// object would be:\n//\n//  package mypackage\n//\n//  import \"v.io/v23/security/access\"\n//\n//  type MyTag string\n//\n//  const (\n//    Blue = MyTag(\"Blue\")\n//    Red  = MyTag(\"Red\")\n//  )\n//\n//  type MyObject interface {\n//    MyMethod() (string, error) {Blue}\n//\n//    // Allow clients to change access via the access.Object interface:\n//    SetPermissions(perms access.Permissions, version string) error         {Red}\n//    GetPermissions() (perms access.Permissions, version string, err error) {Blue}\n//  }"
    },
    {
      name: 'SyncGroupManager',
      pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
      doc: "// SyncGroupManager is the interface for SyncGroup operations.\n// TODO(hpucha): Add blessings to create/join and add a refresh method."
    },
    ],
  methods: [
    
      
    {
    name: 'Create',
    doc: "// Create creates this Database.\n// If perms is nil, we inherit (copy) the App perms.\n// Create requires the caller to have Write permission at the App.",
    inArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete deletes this Database.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'BeginBatch',
    doc: "// BeginBatch creates a new batch. It returns an App-relative name for a\n// Database handle bound to this batch. If this Database is already bound to a\n// batch, BeginBatch() will fail with ErrBoundToBatch.\n//\n// Concurrency semantics are documented in model.go.",
    inArgs: [{
      name: 'bo',
      doc: "",
      type: _typeBatchOptions
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Commit',
    doc: "// Commit persists the pending changes to the database.\n// If this Database is not bound to a batch, Commit() will fail with\n// ErrNotBoundToBatch.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Exec',
    doc: "// Exec executes a syncQL query and returns all results as specified by\n// in the query's select clause.  The returned stream reads\n// from a consistent snapshot taken at the time of the Exec RPC.",
    inArgs: [{
      name: 'query',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _type3
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Abort',
    doc: "// Abort notifies the server that any pending changes can be discarded.\n// It is not strictly required, but it may allow the server to release locks\n// or other resources sooner than if it was not called.\n// If this Database is not bound to a batch, Abort() will fail with\n// ErrNotBoundToBatch.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetPermissions',
    doc: "// SetPermissions replaces the current Permissions for an object.  version\n// allows for optional, optimistic concurrency control.  If non-empty,\n// version's value must come from GetPermissions.  If any client has\n// successfully called SetPermissions in the meantime, the version will be\n// stale and SetPermissions will fail.  If empty, SetPermissions performs an\n// unconditional update.\n//\n// Permissions objects are expected to be small.  It is up to the\n// implementation to define the exact limit, though it should probably be\n// around 100KB.  Large lists of principals can be represented concisely using\n// blessings.\n//\n// There is some ambiguity when calling SetPermissions on a mount point.\n// Does it affect the mount itself or does it affect the service endpoint\n// that the mount points to?  The chosen behavior is that it affects the\n// service endpoint.  To modify the mount point's Permissions, use\n// ResolveToMountTable to get an endpoint and call SetPermissions on that.\n// This means that clients must know when a name refers to a mount point to\n// change its Permissions.",
    inArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetPermissions',
    doc: "// GetPermissions returns the complete, current Permissions for an object. The\n// returned version can be passed to a subsequent call to SetPermissions for\n// optimistic concurrency control. A successful call to SetPermissions will\n// invalidate version, and the client must call GetPermissions again to get\n// the current version.",
    inArgs: [],
    outArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncGroupNames',
    doc: "// GetSyncGroupNames returns the global names of all SyncGroups attached to\n// this database.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _type1
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'CreateSyncGroup',
    doc: "// CreateSyncGroup creates a new SyncGroup with the given spec.\n//\n// Requires: Client must have at least Read access on the Database; prefix ACL\n// must exist at each SyncGroup prefix; Client must have at least Read access\n// on each of these prefix ACLs.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncGroupMemberInfo
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'JoinSyncGroup',
    doc: "// JoinSyncGroup joins the SyncGroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'myInfo',
      doc: "",
      type: _typeSyncGroupMemberInfo
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'LeaveSyncGroup',
    doc: "// LeaveSyncGroup leaves the SyncGroup. Previously synced data will continue\n// to be available.\n//\n// Requires: Client must have at least Read access on the Database.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DestroySyncGroup',
    doc: "// DestroySyncGroup destroys the SyncGroup. Previously synced data will\n// continue to be available to all members.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'EjectFromSyncGroup',
    doc: "// EjectFromSyncGroup ejects a member from the SyncGroup. The ejected member\n// will not be able to sync further, but will retain any data it has already\n// synced.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'member',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncGroupSpec',
    doc: "// GetSyncGroupSpec gets the SyncGroup spec. version allows for atomic\n// read-modify-write of the spec - see comment for SetSyncGroupSpec.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetSyncGroupSpec',
    doc: "// SetSyncGroupSpec sets the SyncGroup spec. version may be either empty or\n// the value from a previous Get. If not empty, Set will only succeed if the\n// current version matches the specified one.\n//\n// Requires: Client must have at least Read access on the Database, and must\n// have Admin access on the SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'spec',
      doc: "",
      type: _typeSyncGroupSpec
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetSyncGroupMembers',
    doc: "// GetSyncGroupMembers gets the info objects for members of the SyncGroup.\n//\n// Requires: Client must have at least Read access on the Database and on the\n// SyncGroup ACL.",
    inArgs: [{
      name: 'sgName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: 'members',
      doc: "",
      type: _type2
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Table(){}
module.exports.Table = Table;

    
      
Table.prototype.create = function(ctx, serverCall, perms) {
  throw new Error('Method Create not implemented');
};
    
      
Table.prototype.delete = function(ctx, serverCall) {
  throw new Error('Method Delete not implemented');
};
    
      
Table.prototype.deleteRowRange = function(ctx, serverCall, start, limit) {
  throw new Error('Method DeleteRowRange not implemented');
};
    
      
Table.prototype.scan = function(ctx, serverCall, start, limit) {
  throw new Error('Method Scan not implemented');
};
    
      
Table.prototype.setPermissions = function(ctx, serverCall, prefix, perms) {
  throw new Error('Method SetPermissions not implemented');
};
    
      
Table.prototype.getPermissions = function(ctx, serverCall, key) {
  throw new Error('Method GetPermissions not implemented');
};
    
      
Table.prototype.deletePermissions = function(ctx, serverCall, prefix) {
  throw new Error('Method DeletePermissions not implemented');
};
     

    
Table.prototype._serviceDescription = {
  name: 'Table',
  pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
  doc: "// Table represents a collection of Rows.\n// Table.Glob operates over the primary keys of Rows in the Table.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Create',
    doc: "// Create creates this Table.\n// If perms is nil, we inherit (copy) the Database perms.",
    inArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete deletes this Table.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeleteRowRange',
    doc: "// Delete deletes all rows in the given half-open range [start, limit). If\n// limit is \"\", all rows with keys >= start are included. If the last row that\n// is covered by a prefix from SetPermissions is deleted, that (prefix, perms)\n// pair is removed.\n// TODO(sadovsky): Automatic GC interacts poorly with sync. Revisit this API.",
    inArgs: [{
      name: 'start',
      doc: "",
      type: _type4
    },
    {
      name: 'limit',
      doc: "",
      type: _type4
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Scan',
    doc: "// Scan returns all rows in the given half-open range [start, limit). If limit\n// is \"\", all rows with keys >= start are included. The returned stream reads\n// from a consistent snapshot taken at the time of the Scan RPC.",
    inArgs: [{
      name: 'start',
      doc: "",
      type: _type4
    },
    {
      name: 'limit',
      doc: "",
      type: _type4
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: {
      name: '',
      doc: '',
      type: _typeKeyValue
    },
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetPermissions',
    doc: "// SetPermissions sets the permissions for all current and future rows with\n// the given prefix. If the prefix overlaps with an existing prefix, the\n// longest prefix that matches a row applies. For example:\n//     SetPermissions(ctx, Prefix(\"a/b\"), perms1)\n//     SetPermissions(ctx, Prefix(\"a/b/c\"), perms2)\n// The permissions for row \"a/b/1\" are perms1, and the permissions for row\n// \"a/b/c/1\" are perms2.\n//\n// SetPermissions will fail if called with a prefix that does not match any\n// rows.",
    inArgs: [{
      name: 'prefix',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetPermissions',
    doc: "// GetPermissions returns an array of (prefix, perms) pairs. The array is\n// sorted from longest prefix to shortest, so element zero is the one that\n// applies to the row with the given key. The last element is always the\n// prefix \"\" which represents the table's permissions -- the array will always\n// have at least one element.",
    inArgs: [{
      name: 'key',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: _type5
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeletePermissions',
    doc: "// DeletePermissions deletes the permissions for the specified prefix. Any\n// rows covered by this prefix will use the next longest prefix's permissions\n// (see the array returned by GetPermissions).",
    inArgs: [{
      name: 'prefix',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Row(){}
module.exports.Row = Row;

    
      
Row.prototype.get = function(ctx, serverCall) {
  throw new Error('Method Get not implemented');
};
    
      
Row.prototype.put = function(ctx, serverCall, value) {
  throw new Error('Method Put not implemented');
};
    
      
Row.prototype.delete = function(ctx, serverCall) {
  throw new Error('Method Delete not implemented');
};
     

    
Row.prototype._serviceDescription = {
  name: 'Row',
  pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
  doc: "// Row represents a single row in a Table.\n// All access checks are performed against the most specific matching prefix\n// permissions in the Table.\n// NOTE(sadovsky): Currently we send []byte values over the wire for Get, Put,\n// and Scan. If there's a way to avoid encoding/decoding on the server side, we\n// can use vdl.Value everywhere without sacrificing performance.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Get',
    doc: "// Get returns the value for this Row.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _type4
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Put',
    doc: "// Put writes the given value for this Row.",
    inArgs: [{
      name: 'value',
      doc: "",
      type: _type4
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete deletes this Row.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
     
  ]
};

   

   
 


