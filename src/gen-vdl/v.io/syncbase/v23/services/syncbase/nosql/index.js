// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
var vdl = require('vanadium').vdl;
var makeError = require('vanadium').verror.makeError;
var actions = require('vanadium').verror.actions;
var canonicalize = require('vanadium').vdl.canonicalize;





var access = require('./../../../../../v23/security/access');
var permissions = require('./../../../../../v23/services/permissions');

module.exports = {};



// Types:
var _type1 = new vdl.Type();
var _typeBatchOptions = new vdl.Type();
var _typePrefixPermissions = new vdl.Type();
_type1.kind = vdl.kind.LIST;
_type1.name = "";
_type1.elem = _typePrefixPermissions;
_typeBatchOptions.kind = vdl.kind.STRUCT;
_typeBatchOptions.name = "v.io/syncbase/v23/services/syncbase/nosql.BatchOptions";
_typeBatchOptions.fields = [{name: "Hint", type: vdl.types.STRING}, {name: "ReadOnly", type: vdl.types.BOOL}];
_typePrefixPermissions.kind = vdl.kind.STRUCT;
_typePrefixPermissions.name = "v.io/syncbase/v23/services/syncbase/nosql.PrefixPermissions";
_typePrefixPermissions.fields = [{name: "Prefix", type: vdl.types.STRING}, {name: "Perms", type: new access.Permissions()._type}];
_type1.freeze();
_typeBatchOptions.freeze();
_typePrefixPermissions.freeze();
module.exports.BatchOptions = (vdl.registry.lookupOrCreateConstructor(_typeBatchOptions));
module.exports.PrefixPermissions = (vdl.registry.lookupOrCreateConstructor(_typePrefixPermissions));




// Consts:



// Errors:

module.exports.BoundToBatchError = makeError('v.io/syncbase/v23/services/syncbase/nosql.BoundToBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} bound to batch',
}, [
]);


module.exports.NotBoundToBatchError = makeError('v.io/syncbase/v23/services/syncbase/nosql.NotBoundToBatch', actions.NO_RETRY, {
  'en': '{1:}{2:} not bound to batch',
}, [
]);




// Services:

  
    
function Database(){}
module.exports.Database = Database;

    
      
Database.prototype.create = function(ctx, serverCall, perms) {
  throw new Error('Method Create not implemented');
};
    
      
Database.prototype.delete = function(ctx, serverCall) {
  throw new Error('Method Delete not implemented');
};
    
      
Database.prototype.beginBatch = function(ctx, serverCall, bo) {
  throw new Error('Method BeginBatch not implemented');
};
    
      
Database.prototype.commit = function(ctx, serverCall) {
  throw new Error('Method Commit not implemented');
};
    
      
Database.prototype.abort = function(ctx, serverCall) {
  throw new Error('Method Abort not implemented');
};
    
      
Database.prototype.setPermissions = function(ctx, serverCall, perms, version) {
  throw new Error('Method SetPermissions not implemented');
};
    
      
Database.prototype.getPermissions = function(ctx, serverCall) {
  throw new Error('Method GetPermissions not implemented');
};
     

    
Database.prototype._serviceDescription = {
  name: 'Database',
  pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
  doc: "// Database represents a collection of Tables. Batches, queries, sync, watch,\n// etc. all operate at the Database level.\n// Database.Glob operates over Table names.\n//\n// TODO(sadovsky): Add Watch method.",
  embeds: [{
      name: 'Object',
      pkgPath: 'v.io/v23/services/permissions',
      doc: "// Object provides access control for Vanadium objects.\n//\n// Vanadium services implementing dynamic access control would typically embed\n// this interface and tag additional methods defined by the service with one of\n// Admin, Read, Write, Resolve etc. For example, the VDL definition of the\n// object would be:\n//\n//   package mypackage\n//\n//   import \"v.io/v23/security/access\"\n//   import \"v.io/v23/services/permissions\"\n//\n//   type MyObject interface {\n//     permissions.Object\n//     MyRead() (string, error) {access.Read}\n//     MyWrite(string) error    {access.Write}\n//   }\n//\n// If the set of pre-defined tags is insufficient, services may define their\n// own tag type and annotate all methods with this new type.\n//\n// Instead of embedding this Object interface, define SetPermissions and\n// GetPermissions in their own interface. Authorization policies will typically\n// respect annotations of a single type. For example, the VDL definition of an\n// object would be:\n//\n//  package mypackage\n//\n//  import \"v.io/v23/security/access\"\n//\n//  type MyTag string\n//\n//  const (\n//    Blue = MyTag(\"Blue\")\n//    Red  = MyTag(\"Red\")\n//  )\n//\n//  type MyObject interface {\n//    MyMethod() (string, error) {Blue}\n//\n//    // Allow clients to change access via the access.Object interface:\n//    SetPermissions(perms access.Permissions, version string) error         {Red}\n//    GetPermissions() (perms access.Permissions, version string, err error) {Blue}\n//  }"
    },
    ],
  methods: [
    
      
    {
    name: 'Create',
    doc: "// Create creates this Database.\n// If perms is nil, we inherit (copy) the App perms.\n// Create requires the caller to have Write permission at the App.",
    inArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete deletes this Database.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'BeginBatch',
    doc: "// BeginBatch creates a new batch. It returns an App-relative name for a\n// Database handle bound to this batch. If this Database is already bound to a\n// batch, BeginBatch() will fail with ErrBoundToBatch.\n//\n// Concurrency semantics are documented in model.go.",
    inArgs: [{
      name: 'bo',
      doc: "",
      type: _typeBatchOptions
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Commit',
    doc: "// Commit persists the pending changes to the database.\n// If this Database is not bound to a batch, Commit() will fail with\n// ErrNotBoundToBatch.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Abort',
    doc: "// Abort notifies the server that any pending changes can be discarded.\n// It is not strictly required, but it may allow the server to release locks\n// or other resources sooner than if it was not called.\n// If this Database is not bound to a batch, Abort() will fail with\n// ErrNotBoundToBatch.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetPermissions',
    doc: "// SetPermissions replaces the current Permissions for an object.  version\n// allows for optional, optimistic concurrency control.  If non-empty,\n// version's value must come from GetPermissions.  If any client has\n// successfully called SetPermissions in the meantime, the version will be\n// stale and SetPermissions will fail.  If empty, SetPermissions performs an\n// unconditional update.\n//\n// Permissions objects are expected to be small.  It is up to the\n// implementation to define the exact limit, though it should probably be\n// around 100KB.  Large lists of principals can be represented concisely using\n// blessings.\n//\n// There is some ambiguity when calling SetPermissions on a mount point.\n// Does it affect the mount itself or does it affect the service endpoint\n// that the mount points to?  The chosen behavior is that it affects the\n// service endpoint.  To modify the mount point's Permissions, use\n// ResolveToMountTable to get an endpoint and call SetPermissions on that.\n// This means that clients must know when a name refers to a mount point to\n// change its Permissions.",
    inArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetPermissions',
    doc: "// GetPermissions returns the complete, current Permissions for an object. The\n// returned version can be passed to a subsequent call to SetPermissions for\n// optimistic concurrency control. A successful call to SetPermissions will\n// invalidate version, and the client must call GetPermissions again to get\n// the current version.",
    inArgs: [],
    outArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    {
      name: 'version',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Table(){}
module.exports.Table = Table;

    
      
Table.prototype.create = function(ctx, serverCall, perms) {
  throw new Error('Method Create not implemented');
};
    
      
Table.prototype.delete = function(ctx, serverCall) {
  throw new Error('Method Delete not implemented');
};
    
      
Table.prototype.deleteRowRange = function(ctx, serverCall, start, limit) {
  throw new Error('Method DeleteRowRange not implemented');
};
    
      
Table.prototype.setPermissions = function(ctx, serverCall, prefix, perms) {
  throw new Error('Method SetPermissions not implemented');
};
    
      
Table.prototype.getPermissions = function(ctx, serverCall, key) {
  throw new Error('Method GetPermissions not implemented');
};
    
      
Table.prototype.deletePermissions = function(ctx, serverCall, prefix) {
  throw new Error('Method DeletePermissions not implemented');
};
     

    
Table.prototype._serviceDescription = {
  name: 'Table',
  pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
  doc: "// Table represents a collection of Rows.\n// Table.Glob operates over the primary keys of Rows in the Table.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Create',
    doc: "// Create creates this Table.\n// If perms is nil, we inherit (copy) the Database perms.",
    inArgs: [{
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete deletes this Table.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeleteRowRange',
    doc: "// DeleteRowRange deletes all rows in the given range. If the last row that is\n// covered by a prefix from SetPermissions is deleted, that (prefix, perms)\n// pair is removed.\n// TODO(sadovsky): Automatic GC does not interact well with sync. This API\n// needs to be revisited.",
    inArgs: [{
      name: 'start',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'limit',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'SetPermissions',
    doc: "// SetPermissions sets the permissions for all current and future rows with\n// the given prefix. If the prefix overlaps with an existing prefix, the\n// longest prefix that matches a row applies. For example:\n//     SetPermissions(ctx, Prefix(\"a/b\"), perms1)\n//     SetPermissions(ctx, Prefix(\"a/b/c\"), perms2)\n// The permissions for row \"a/b/1\" are perms1, and the permissions for row\n// \"a/b/c/1\" are perms2.\n//\n// SetPermissions will fail if called with a prefix that does not match any\n// rows.",
    inArgs: [{
      name: 'prefix',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'perms',
      doc: "",
      type: new access.Permissions()._type
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'GetPermissions',
    doc: "// GetPermissions returns an array of (prefix, perms) pairs. The array is\n// sorted from longest prefix to shortest, so element zero is the one that\n// applies to the row with the given key. The last element is always the\n// prefix \"\" which represents the table's permissions -- the array will always\n// have at least one element.",
    inArgs: [{
      name: 'key',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: _type1
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'DeletePermissions',
    doc: "// DeletePermissions deletes the permissions for the specified prefix. Any\n// rows covered by this prefix will use the next longest prefix's permissions\n// (see the array returned by GetPermissions).",
    inArgs: [{
      name: 'prefix',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Admin", true), new access.Tag()._type), ]
  },
     
  ]
};

  
    
function Row(){}
module.exports.Row = Row;

    
      
Row.prototype.get = function(ctx, serverCall) {
  throw new Error('Method Get not implemented');
};
    
      
Row.prototype.put = function(ctx, serverCall, value) {
  throw new Error('Method Put not implemented');
};
    
      
Row.prototype.delete = function(ctx, serverCall) {
  throw new Error('Method Delete not implemented');
};
     

    
Row.prototype._serviceDescription = {
  name: 'Row',
  pkgPath: 'v.io/syncbase/v23/services/syncbase/nosql',
  doc: "// Row represents a single row in a Table.\n// All access checks are performed against the most specific matching prefix\n// permissions in the Table.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Get',
    doc: "// Get returns the value for this Row.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.ANY
    },
    ],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Read", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Put',
    doc: "// Put writes the given value for this Row.",
    inArgs: [{
      name: 'value',
      doc: "",
      type: vdl.types.ANY
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete deletes this Row.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: [canonicalize.reduce(new access.Tag("Write", true), new access.Tag()._type), ]
  },
     
  ]
};

   

   
 


